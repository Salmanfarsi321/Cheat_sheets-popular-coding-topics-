----------------------------------------------------------------Dynamic programming (Leetcode)--------------------------------------------------------------------

Que1:Longest palindromic substring

string longestPalindrome(string s){
        int n=s.size();
        int maxlen=1,start=0;
        for(int i=1;i<n;i++){
            int lo=i-1,hi=i;
            while(lo>=0 && hi<n && s[lo]==s[hi]){
                if(hi-lo+1>maxlen){
                    maxlen=hi-lo+1;
                    start=lo;
                }
                lo--;
                hi++;
            }
        }  
        int odd_ans=0;
        for(int i=1;i<n;i++){
            int lo=i-1,hi=i+1;
            while(lo>=0 && hi<n && s[lo]==s[hi]){
                if(hi-lo+1>maxlen){
                    maxlen=hi-lo+1;
                    start=lo;
                }
                lo--;
                hi++;
            }
        }
        return s.substr(start,maxlen);
 }


//O(n*n)
int longestPalSubstr(string str) 
{ 
    // get length of input string 
    int n = str.size(); 
  
    // table[i][j] will be false if substring 
    // str[i..j] is not palindrome. 
    // Else table[i][j] will be true 
    bool table[n][n]; 
  
    memset(table, 0, sizeof(table)); 
  
    // All substrings of length 1 
    // are palindromes 
    int maxLength = 1; 
  
    for (int i = 0; i < n; ++i) 
        table[i][i] = true; 
  
    // check for sub-string of length 2. 
    int start = 0; 
    for (int i = 0; i < n - 1; ++i) { 
        if (str[i] == str[i + 1]) { 
            table[i][i + 1] = true; 
            start = i; 
            maxLength = 2; 
        } 
    } 
  
    // Check for lengths greater than 2. 
    // len is length of substring 
    for (int len = 3; len <= n; len++) { 
        // Fix the starting index 
        for (int i = 0; i < n - len + 1; ++i) { 
            // Get the ending index of substring from 
            // starting index i and length k 
            int j = i + len - 1; 
  
            // checking for sub-string from ith index to 
            // jth index iff str[i+1] to str[j-1] is a 
            // palindrome 
            if (table[i + 1][j - 1] && str[i] == str[j]) { 
                table[i][j] = true; 
  
                if (len > maxLength) { 
                    start = i; 
                    maxLength = len;
                } 
            } 
        } 
    } 
  

Que2:Longest increasing subsequence O(n logn)	---> very important

int len(vector<int>a){
	if(a.size()==0)
	return 0;
	vector<int> v;
	v.push_back(a[0]);
	for(int i=1;i<a.size();i++)
	{
		if(a[i]>v.back())
		v.push_back(a[i]);
		else if(a[i]<v.back())
		{
			if(!binary_search(v.begin(),v.end(),a[i]))
			{
				int temp=upper_bound(v.begin(),v.end(),a[i])-v.begin();
				v[temp]=a[i];		
			}
		}
	}
	return v.size();
}

Que3:Wildcard matching

 bool isMatch(string s, string p) 
    {
        int n=s.size(),m=p.size();
        vector<vector<bool> >dp(n+1,vector<bool>(m+1));
	//dp[i][j] represents whether substring s[0...i] and p[0...j] matches or not
        dp[0][0]=true;
        for(int i=1;i<=n;i++)	
            dp[i][0]=false;		// if pattern length is ""
        for(int j=1;j<=m;j++){
            if(p[j-1]=='*')		//if s is "" and pattern is like ******* ,then also it will be true
            dp[0][j]=dp[0][j-1];	
            else
            dp[0][j]=false;		//if s is "" and pattern is like a****,then it will be false 
        }
        for(int i=1;i<=n;i++){
            for(int j=1;j<=m;j++){
                if(p[j-1]=='?' || s[i-1]==p[j-1])
                    dp[i][j]=dp[i-1][j-1];
                else if(p[j-1]=='*')
                    dp[i][j]=dp[i-1][j] || dp[i][j-1];
                else
                    dp[i][j]=false;	// if p[j-1]!=s[i-1]
            }
        }
        return dp[n][m];
    }

Que4:Regular expression matching

1, If p.charAt(j) == s.charAt(i) :  dp[i][j] = dp[i-1][j-1];
2, If p.charAt(j) == '.' : dp[i][j] = dp[i-1][j-1];
3, If p.charAt(j) == '*': 
   here are two sub conditions:
               1   if p.charAt(j-1) != s.charAt(i) : dp[i][j] = dp[i][j-2]  //in this case, a* only counts as empty
               2   if p.charAt(i-1) == s.charAt(i) or p.charAt(i-1) == '.':
                              dp[i][j] = dp[i-1][j]    //in this case, a* counts as multiple a 
                           or dp[i][j] = dp[i][j-1]   // in this case, a* counts as single a
                           or dp[i][j] = dp[i][j-2]   // in this case, a* counts as empty

 public boolean isMatch(String s, String p) {
        if(s == null || p == null) {
            return false;
        }
        boolean[][] state = new boolean[s.length() + 1][p.length() + 1];
        state[0][0] = true;
        // no need to initialize state[i][0] as false
        // initialize state[0][j]
        for (int j = 1; j < state[0].length; j++) {
            if (p.charAt(j - 1) == '*') {
                if (state[0][j - 1] || (j > 1 && state[0][j - 2])) {
                    state[0][j] = true;
                }
            } 
        }
        for (int i = 1; i < state.length; i++) {
            for (int j = 1; j < state[0].length; j++) {
                if (s.charAt(i - 1) == p.charAt(j - 1) || p.charAt(j - 1) == '.') {
                    state[i][j] = state[i - 1][j - 1];
                }
                if (p.charAt(j - 1) == '*') {
                    if (s.charAt(i - 1) != p.charAt(j - 2) && p.charAt(j - 2) != '.') {
                        state[i][j] = state[i][j - 2];
                    } else {
                        state[i][j] = state[i - 1][j] || state[i][j - 1] || state[i][j - 2];
                    }
                }
            }
        }
        return state[s.length()][p.length()];
    }

Que5:Longest valid parenthesis

Input: "(()"
Output: 2

Input: ")()())"
Output: 4

int longestValidParentheses(string s) 
    {
        int n=s.size();
        stack<int>stk;
        int mx=0;
        stk.push(-1);		------> Notice this line
        for(int i=0;i<n;i++)
        {
            if(s[i]=='(')
                stk.push(i);
            else
            {
                stk.pop();
                if(stk.empty())
                    stk.push(i);
                else
                {
                    mx=max(mx,i-stk.top());
                }
            }
        }
        return mx;
    }

Que6:Edit distance (find the minimum number of operations required to convert word1 to word2)

 int minDistance(string str1, string str2)
    {
        int n=str1.size();
        int m=str2.size();
	int dp[n+1][m+1];
	for(int i=0;i<=n;i++)
	{
	    for(int j=0;j<=m;j++)
	    {
	            if(i==0) dp[i][j]=j;		//if no characters in word1 then insert characters of word2
	            else if(j==0) dp[i][j]=i;		//if no characters in word2 then delete characters of word1
	            else if(str1[i-1]==str2[j-1])
	            dp[i][j]=dp[i-1][j-1];
	            else
	            dp[i][j]=1+min({dp[i-1][j],dp[i][j-1],dp[i-1][j-1]});
	     }
	 }
	    return dp[n][m];
    }


Que7:Minimum path sum  

Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path.

Note: You can only move either down or right at any point in time.

int minPathSum(vector<vector<int>>& grid)
    {
        int n=grid.size();
        int m=grid[0].size();
        int dp[n][m];
        memset(dp,0,sizeof(dp));
        dp[0][0]=grid[0][0];
        for(int i=1;i<n;i++)
        dp[i][0]=dp[i-1][0]+grid[i][0];
        for(int i=1;i<m;i++)
        dp[0][i]=dp[0][i-1]+grid[0][i];
        for(int i=1;i<n;i++)
        {
            for(int j=1;j<m;j++)
            {
                dp[i][j]=grid[i][j]+min(dp[i-1][j],dp[i][j-1]);
            }
        }
        return dp[n-1][m-1];
    }   

Que8: Unique paths

A robot is located at the top-left corner of a m x n grid .
The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid 
Now consider if some obstacles are added to the grids. How many unique paths would there be? obstacle->1 , free space->0

int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) 
    {
        int m=obstacleGrid.size();
        int n=obstacleGrid[0].size();
        long dp[m][n];
        memset(dp,0,sizeof(dp));
        if(obstacleGrid[0][0]==1)
            return 0;
        for(int i=0;i<n;i++)
        {
            if(obstacleGrid[0][i]==1)
            break;
            else
            dp[0][i]=1;
        }
        for(int j=0;j<m;j++)
        {
            if(obstacleGrid[j][0]==1)
            break;
            else
            dp[j][0]=1;
        }
        for(int i=1;i<m;i++)
        {
            for(int j=1;j<n;j++)
            {
                if(obstacleGrid[i][j]==0)
                    dp[i][j]=dp[i-1][j]+dp[i][j-1];
                else
                    dp[i][j]=0;
            }
        }
        return dp[m-1][n-1];
    }


Que9: Climbing stairs 

You are climbing a stair case. It takes n steps to reach to the top.
Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?

 int climbStairs(int n) 
    {
        int dp[n+1];
        memset(dp,0,sizeof(dp));
        dp[1]=1;
        if(n>1)
        {
        dp[2]=2;
        for(int i=3;i<=n;i++)
            dp[i]=dp[i-1]+dp[i-2];
        }
        return dp[n];
    }

Que10: Maximal rectangle 	(Very important)

int max_area_histogram(vector<int>v){
    stack<pair<int,int> >stk;
    int n=v.size();
    vector<int>left;
    vector<int>right;
    //next smaller element left
    for(int i=0;i<v.size();i++){
        while(!stk.empty() && stk.top().first>=v[i])
        stk.pop();
        if(stk.empty())
        left.push_back(-1);
        else
        left.push_back(stk.top().second);
        stk.push({v[i],i});
    }
    while(!stk.empty()) stk.pop();
    //next smaller element right
    for(int i=n-1;i>=0;i--){
        while(!stk.empty() && stk.top().first>=v[i])
        stk.pop();
        if(stk.empty()) right.push_back(n);
        else
        right.push_back(stk.top().second);
        stk.push({v[i],i});
    }
    reverse(right.begin(),right.end());
    int mx=0;
    for(int i=0;i<n;i++){
        int val=(right[i]-left[i]-1)*v[i];
        mx=max(mx,val);
    }
    return mx;
}
public:
    int maximalRectangle(vector<vector<char>>& M) {
    int ans=0;
    int n=M.size();
    if(n==0) return 0;
    int m=M[0].size();
    vector<int>v(m,0);
    for(int i=0;i<n;i++){
        for(int j=0;j<m;j++){
            if(M[i][j]=='0')
            v[j]=0;
            else
            v[j]+=M[i][j]-'0';
        }
        ans=max(ans,max_area_histogram(v));
    }
    return ans;
    }


Que 11: Maximal square

int max_area_histogram(vector<int>v){
    stack<pair<int,int> >stk;
    int n=v.size();
    vector<int>left;
    vector<int>right;
    //next smaller element left
    for(int i=0;i<v.size();i++){
        while(!stk.empty() && stk.top().first>=v[i])
        stk.pop();
        if(stk.empty())
        left.push_back(-1);
        else
        left.push_back(stk.top().second);
        stk.push({v[i],i});
    }
    while(!stk.empty()) stk.pop();
    //next smaller element right
    for(int i=n-1;i>=0;i--){
        while(!stk.empty() && stk.top().first>=v[i])
        stk.pop();
        if(stk.empty()) right.push_back(n);
        else
        right.push_back(stk.top().second);
        stk.push({v[i],i});
    }
    reverse(right.begin(),right.end());
    int mx=0;
    for(int i=0;i<n;i++){
        int width=(right[i]-left[i]-1);
	int height=v[i];
	int side=min(width,height);	// Notice the difference between the maximal square and rectangle which is on above
        mx=max(mx,side*side);
    }
    return mx;
}
public:
    int maximalSquare(vector<vector<char>>& M) {
    int ans=0;
    int n=M.size();
    if(n==0) return 0;
    int m=M[0].size();
    vector<int>v(m,0);
    for(int i=0;i<n;i++){
        for(int j=0;j<m;j++){
            if(M[i][j]=='0')
            v[j]=0;
            else
            v[j]+=M[i][j]-'0';
        }
        ans=max(ans,max_area_histogram(v));
    }
    return ans;
    }

Que 12: Scramble string

bool isScramble(string s1, string s2) {
        if(s1==s2)
            return true;
        int count[26] = {0};
        int n=s1.size();
        for(int i=0; i<n; i++)
        {
            count[s1[i]-'a']++;
            count[s2[i]-'a']--;
        } 
        for(int i=0; i<26; i++)
        {
            if(count[i]!=0)
                return false;
        }
        bool flag=false;
        for(int i=1;i<=n-1;i++){
            bool cond1=isScramble(s1.substr(0,i),s2.substr(n-i,i)) &&
                       isScramble(s1.substr(i,n-i),s2.substr(0,n-i));
            bool cond2=isScramble(s1.substr(0,i),s2.substr(0,i)) && 
                       isScramble(s1.substr(i,n-i),s2.substr(i,n-i));
            if(cond1 || cond2){
                flag=true;
                break;
            }
        }
       return flag; 
    }

Que13: Maximum product subarray		----> Love this one

 int maxProduct(vector<int>& a)
    {
        
        int n=a.size();
        int curr_max_product=a[0];
        int curr_min_product=a[0];
        int prev_max_product=a[0];
        int prev_min_product=a[0];
        int ans=a[0];
        for(int i=1;i<n;i++)
        {
	   //three choices either the current element is positive,negative or we want to start a new subarray starting with the current element
	   curr_max_product=max(prev_max_product*a[i],max(prev_min_product*a[i],a[i]));
           curr_min_product=min(prev_max_product*a[i],min(prev_min_product*a[i],a[i]));
           ans=max(ans,curr_max_product);
           prev_max_product=curr_max_product;
           prev_min_product=curr_min_product;
        }
        return ans;
    }

Que14: Dungeon game	(very important)

int calculateMinimumHP(vector<vector<int>>& mat) 
    {
        int n=mat.size();
        int m=mat[0].size();
        int dp[n+1][m+1];
        for(int i=0;i<=n;i++)
        {
            dp[i][m]=INT_MAX;
        }
        for(int i=0;i<=m;i++)
        {
            dp[n][i]=INT_MAX;
        }
        dp[n-1][m]=0,dp[n][m-1]=0;
        for(int i=n-1;i>=0;i--)
        {
            for(int j=m-1;j>=0;j--)
            {
		//if need becomes less than 0 it means the value at matrix[i][j] is positive and we need 0 health there,hence dp[i][j]=0
                dp[i][j]=max(min(dp[i+1][j],dp[i][j+1])-mat[i][j],0);		
            }
        }
        return dp[0][0]+1;
    }

Que15: House robber 2	--> BEAUTIFUL approach

int rob(vector<int>& nums) 
    {
        int n=nums.size();
        if(n==0) return 0;
        if(n==1) return nums[0];
        int dp[n];
        dp[0]=nums[0];				//robbing houses including 0th house upto house no (n-2) ,maximum stored in dp[n-2]
        dp[1]=max(nums[0],nums[1]);		//since 0th house is included, (n-1)th house is excluded (we can only choose one of them)
        for(int i=2;i<n-1;i++)
        {
            dp[i]=max(dp[i-2]+nums[i],dp[i-1]);
        }
        int mx=dp[n-2];
        memset(dp,0,sizeof(dp));
        dp[0]=0;				//robbing houses excluding 0th house upto house no (n-1) ,maximum stored in dp[n-1]
        dp[1]=nums[1];				//since 0th house is excluded, (n-1)th house is included (we can only choose one of them)
        for(int i=2;i<n;i++)
        {
            dp[i]=max(dp[i-2]+nums[i],dp[i-1]);
        }
        mx=max(mx,dp[n-1]);			//lastly take the maximum of dp[n-2] and dp[n-1]
        return mx;
    }


Que 16: Burst balloons		---> asked in codenation 2020  (MCM variation)

 int solve(vector<int>&a,vector<vector<int> >&dp,int i,int j){
        if(i>=j) return 0;
        if(dp[i][j]>0) return dp[i][j];
        int mx=INT_MIN;
        for(int k=i;k<=j-1;k++){
            int temp=a[i-1]*a[k]*a[j] + solve(a,dp,i,k) +
                solve(a,dp,k+1,j);
            mx=max(mx,temp);
        }
        return dp[i][j]=mx;
    }
    
public:
    int maxCoins(vector<int>& nums) 
    {
       int n=nums.size();
       vector<int>a(n+2);
       a[0]=1;
       for(int i=1;i<=n;i++) a[i]=nums[i-1];
       a[n+1]=1;
       vector<vector<int> >dp(n+2,vector<int>(n+2,-1));
       return solve(a,dp,1,n+1);
    }

Que 17: Number of longest incresing subsequence

int findNumberOfLIS(vector<int>& nums) 
    {
        int n=nums.size();
        if(n==0) return 0;
        int dp[n],cnt[n];           //dp[i] represents the maximum length of increasing subsequence ending at index i
				    //cnt[i] represents the number of maximum length of increasing subsequence ending at index i
        int maxlen=0,ans=0;
        for(int i=0;i<n;i++)
        {
            dp[i]=cnt[i]=1;
            for(int j=0;j<i;j++)
            {
                if(nums[j]<nums[i])
                {
                    if(dp[i]==dp[j]+1) cnt[i]+=cnt[j];
                    if(dp[i]<dp[j]+1)
                    {
                        dp[i]=dp[j]+1;
                        cnt[i]=cnt[j];
                    }
                }
            }
            maxlen=max(maxlen,dp[i]);
        }
        for(int i=0;i<n;i++)
        {
            if(dp[i]==maxlen) ans+=cnt[i];
        }
        return ans;
    }

Que 18: Maximal square (dp solution) and another space optimized solution  --->very important to notice how to convert simple dp solution to space optimized version

int maximalSquare(vector<vector<char>>& matrix) {
        if (matrix.empty()) {
            return 0;
        }
        int m = matrix.size(), n = matrix[0].size(), sz = 0;
        vector<vector<int>> dp(m, vector<int>(n, 0));
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (!i || !j || matrix[i][j] == '0') {
                    dp[i][j] = matrix[i][j] - '0';
                } else {
                    dp[i][j] = min(dp[i - 1][j - 1], min(dp[i - 1][j], dp[i][j - 1])) + 1;
                }
                sz = max(dp[i][j], sz);
            }
        }
        return sz * sz;
    }

In the above code, it uses O(mn) space. Actually each time when we update dp[i][j], we only need dp[i-1][j-1], dp[i-1][j] (the previous row) and 
dp[i][j-1] (the current row). So we may just keep two rows.

//space optimized version
 int maximalSquare(vector<vector<char>>& matrix) {
        if (matrix.empty()) {
            return 0;
        }
        int m = matrix.size(), n = matrix[0].size(), sz = 0;
        vector<int> pre(n, 0), cur(n, 0);
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (!i || !j || matrix[i][j] == '0') {
                    cur[j] = matrix[i][j] - '0';
                } else {
                    cur[j] = min(pre[j - 1], min(pre[j], cur[j - 1])) + 1;
                }
                sz = max(cur[j], sz);
            }
            fill(pre.begin(), pre.end(), 0);
            swap(pre, cur);
        }
        return sz * sz;
    }

Que 19:Count of all the palindromic substrings

 int count =1;
    public: int countSubstrings(string s) {
    if(s.length()==0) 
        return 0;
    for(int i=0; i<s.length()-1; i++){
        checkPalindrome(s,i,i);     //To check the palindrome of odd length palindromic sub-string
        checkPalindrome(s,i,i+1);   //To check the palindrome of even length palindromic sub-string
    }
    return count;
}    

private: void checkPalindrome(string s, int i, int j) {
    while(i>=0 && j<s.length() && s[i]==s[j]){    //Check for the palindrome string 
        count++;    	//Increment the count if palindromin substring found
        i--;    	//To trace string in left direction
        j++;    	//To trace string in right direction
    }
}

Que 20: Distinct palindromic substrings

#include<bits/stdc++.h>
using namespace std;
int main()
{
	int t;
	cin>>t;
	while(t--)
	{
	    string s;
	    cin>>s;
	    int n=s.size();
	    set<string>set;
	    vector<vector<bool> >dp(n,vector<bool>(n,false));
	    //dp[i][j] is true if substring (i...j) is palindrome
	    for(int i=0;i<n;i++){
	    dp[i][i]=1;
	    set.insert(s.substr(i,1));
	    //cout<<s.substr(i,1)<<" ";
	    }
	    for(int len=2;len<=n;len++){
	        for(int i=0;i<=n-len;i++){
	            int j=i+len-1;
	            if(s[i]==s[j] && len==2)
	            dp[i][j]=true;
	            else if(s[i]==s[j] && dp[i+1][j-1])
	            dp[i][j]=true;
	            
	            
	            if(dp[i][j]==true){
	            //cout<<s.substr(i,j-i+1)<<" ";
	            set.insert(s.substr(i,j-i+1));
	            }
	        }
	    }
	    cout<<set.size()<<"\n";
	}
	return 0;
}

Que 21: Longest zig zag subsequence

#include<bits/stdc++.h>
using namespace std;
int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
	int t;
	cin>>t;
	while(t--)
	{
	    int n;
	    cin>>n;
	    vector<int>a(n);
	    for(int i=0;i<n;i++) cin>>a[i];
	    vector<vector<int> >dp(n,vector<int>(2));
	    for(int i=0;i<n;i++){
	        dp[i][0]=dp[i][1]=1;
	    }
	    int ans=1;
	    for(int i=1;i<n;i++){
	        for(int j=0;j<i;j++){
	            if(a[j]<a[i]){
	                dp[i][0]=max(dp[i][0],dp[j][1]+1);
	            }
	            else if(a[j]>a[i]){
	                dp[i][1]=max(dp[i][1],dp[j][0]+1);
	            }
	        }
	        ans=max(ans,max(dp[i][0],dp[i][1]));
	    }
	    cout<<ans<<"\n";
	}
}


Que 22: Maximum length of repeated subarray

Given two integer arrays A and B, return the maximum length of an subarray that appears in both arrays.

Example 1:

Input:
A: [1,2,3,2,1]
B: [3,2,1,4,7]
Output: 3
Explanation: 
The repeated subarray with maximum length is [3, 2, 1].

public:
    int findLength(vector<int>& A, vector<int>& B) {
        int n = A.size();
        int m = B.size();
        int dp[n+1][m+1];
        memset(dp,0,sizeof(dp));
        int mx = 0;
        for(int i=1;i<=n;i++){
            for(int j=1;j<=m;j++){
                if(A[i-1] == B[j-1])
                    dp[i][j] = dp[i-1][j-1]+1;
                else
                    dp[i][j] = 0;
                mx = max(mx,dp[i][j]);
            }    
        }
        return mx;
    }

Que 23: Best time to buy and sell stock1

Say you have an array for which the ith element is the price of a given stock on day i.

If you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit.

Note that you cannot sell a stock before you buy one.

Example 1:

Input: [7,1,5,3,6,4]
Output: 5
Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.
             Not 7-1 = 6, as selling price needs to be larger than buying price.

int maxProfit(vector<int>& prices) 
    {
        int n=prices.size();
        int min_price=INT_MAX,ans=0;
        for(int i=0;i<n;i++)
        {
           min_price=min(min_price,prices[i]);
           ans=max(ans,prices[i]-min_price);
        }
        return ans;
    }

Que 23: Best time to buy and sell stock2

Say you have an array prices for which the ith element is the price of a given stock on day i.

Design an algorithm to find the maximum profit. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times).

Note: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again).

Example 1:

Input: [7,1,5,3,6,4]
Output: 7
Explanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.
             Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.


//Approach: This solution follows the logic used in Approach 2 itself, but with only a slight variation. In this case, instead of looking for every peak 
following a valley, we can simply go on crawling over the slope and keep on adding the profit obtained from every consecutive transaction. In the end,we will be 
using the peaks and valleys effectively, but we need not track the costs corresponding to the peaks and valleys along with the maximum profit, but we can directly
keep on adding the difference between the consecutive numbers of the array if the second number is larger than the first one, and at the total sum we obtain will be 
the maximum profit. 

int maxProfit(vector<int>& prices)
    {
        int ans=0;
        for(int i=1;i<prices.size();i++)
        {
            if(prices[i]>prices[i-1])
                ans+=prices[i]-prices[i-1];
        }
        return ans;
    }


Que 24: Best time to buy and sell stock 3

Say you have an array for which the ith element is the price of a given stock on day i.

Design an algorithm to find the maximum profit. You may complete at most two transactions.

Note: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again).

Example 1:

Input: prices = [3,3,5,0,0,3,1,4]
Output: 6
Explanation: Buy on day 4 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.
Then buy on day 7 (price = 1) and sell on day 8 (price = 4), profit = 4-1 = 3.

//Approach
First assume that we have no money, so buy1 means that we have to borrow money from others, we want to borrow less so that we have to make our balance as max as we can(because this is negative).
sell1 means we decide to sell the stock, after selling it we have price[i] money and we have to give back the money we owed, so we have price[i] - |buy1| = prices[i ] + buy1, we want to make this max.
buy2 means we want to buy another stock, we already have sell1 money, so after buying stock2 we have buy2 = sell1 - price[i] money left, we want more money left, so we make it max
sell2 means we want to sell stock2, we can have price[i] money after selling it, and we have buy2 money left before, so sell2 = buy2 + prices[i], we make this max.
So sell2 is the most money we can have.
*/

int maxProfit(vector<int>& prices) 
    {
       int buy1=INT_MIN,buy2=INT_MIN,sell1=0,sell2=0;
       for(int i=0;i<prices.size();i++)
       {
          buy1=max(buy1,-prices[i]);
          sell1=max(sell1,prices[i]+buy1);
          buy2=max(buy2,sell1-prices[i]);
          sell2=max(sell2,prices[i]+buy2);
       }
        return sell2;
    }

Que 25: Best time to buy and sell stock 4

//Approach:The above solution has time complexity of O(k.n2). It can be reduced if we are able to calculate the maximum profit gained by selling shares on the ith day
in constant time.

profit[t][i] = max(profit[t][i-1], max(price[i] – price[j] + profit[t-1][j]))
                            for all j in range [0, i-1]

If we carefully notice,
max(price[i] – price[j] + profit[t-1][j])
for all j in range [0, i-1]

can be rewritten as,
= price[i] + max(profit[t-1][j] – price[j])
for all j in range [0, i-1]
= price[i] + max(prevDiff, profit[t-1][i-1] – price[i-1])
where prevDiff is max(profit[t-1][j] – price[j])
for all j in range [0, i-2]

So, if we have already calculated max(profit[t-1][j] – price[j]) for all j in range [0, i-2], we can calculate it for j = i – 1 in constant time. In other words, 
we don’t have to look back in the range [0, i-1] anymore to find out best day to buy. We can determine that in constant time using below revised relation.

profit[t][i] = max(profit[t][i-1], price[i] + max(prevDiff, profit [t-1][i-1] – price[i-1])
where prevDiff is max(profit[t-1][j] – price[j]) for all j in range [0, i-2]
*/

Say you have an array for which the i-th element is the price of a given stock on day i.
Design an algorithm to find the maximum profit. You may complete at most k transactions.

Note:
You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).

Example 1:

Input: [2,4,1], k = 2
Output: 2
Explanation: Buy on day 1 (price = 2) and sell on day 2 (price = 4), profit = 4-2 = 2.

public:
    int maxProfit(int k, vector<int>& prices) {
        int n = prices.size();
        if(n == 0 ) return 0;
        if (k >= n / 2) return quickSolve(prices);
        //dp[k][n] denotes profit gained by doing k transactions upto nth day
        vector<vector<int> >dp(k+1,vector<int>(n+1,0));
        int prev_diff = 0;
        for(int i=1;i<=k;i++){
            int prev_diff = INT_MIN;
            for(int j=1;j<n;j++){
                prev_diff =  max(prev_diff,dp[i-1][j-1]-prices[j-1]);
                dp[i][j] = max(prices[j] + prev_diff,dp[i][j-1]);
            }
        }
        return dp[k][n-1];
    }
    
     private: int quickSolve(vector<int>&prices) {
        int len = prices.size(), profit = 0;
        for (int i = 1; i < len; i++)
            // as long as there is a price gap, we gain a profit.
            if (prices[i] > prices[i - 1]) profit += prices[i] - prices[i - 1];
        return profit;
    }


Que 26: Best time to buy and sell stock with cooldown

Say you have an array for which the ith element is the price of a given stock on day i.

Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times) with the following restrictions:

You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).
After you sell your stock, you cannot buy stock on next day. (ie, cooldown 1 day)
Example:

Input: [1,2,3,0,2]
Output: 3 
Explanation: transactions = [buy, sell, cooldown, buy, sell]


//Extra space O(n)
 int maxProfit(vector<int>& prices) {
        int n = prices.size();
        if(n <=0) return 0;
        vector<int>s0(n),s1(n),s2(n);
        s0[0] = 0;
        s1[0] = -prices[0];
        s2[0] = INT_MIN;
        for(int i=1;i<n;i++){
            s0[i] = max(s0[i-1],s2[i-1]);
            s1[i] = max(s1[i-1],s0[i-1]-prices[i]);
            s2[i] = s1[i-1]+prices[i];
        }
        return max(s0[n-1],s2[n-1]);
    }

//O(1) space

 int maxProfit(vector<int>& prices) {
        int n = prices.size();
        if(n<=0) return 0;
        int buy = 0;
        int sold = -prices[0];
        int hold = INT_MIN;
        for(int i=1;i<n;i++){
            int prev_sold = sold; 
            int prev_buy = buy;
            buy = max(prev_buy,hold);
            sold = max(prev_sold,prev_buy-prices[i]);
            hold = prev_sold+prices[i];
        }
        return max(buy,hold);
    }

Que 27: Range sum query (Immutable)

Given an integer array nums, find the sum of the elements between indices i and j (i ≤ j), inclusive.

Example:

Given nums = [-2, 0, 3, -5, 2, -1]

sumRange(0, 2) -> 1
sumRange(2, 5) -> -1
sumRange(0, 5) -> -3

const int N=1e4+2;
vector<int>prefix(N);

class NumArray {
    
public:
    NumArray(vector<int>& nums) {
        int n = nums.size();
        prefix[0] = 0;
        for(int i=0;i<nums.size();i++) prefix[i+1] = prefix[i]+nums[i];
    }
    
    int sumRange(int i, int j) {
        return prefix[j+1]-prefix[i];
    }
};


Que 28: Range sum query 2


class NumMatrix {
     int pre[1000][1000];
public:
    NumMatrix(vector<vector<int>>& matrix) {
        int n = matrix.size();
        if(n == 0) return;
        int m = matrix[0].size();
        if(m == 0) return;
        pre[0][0] = matrix[0][0];
        for(int i=1;i<m;i++) pre[0][i] = pre[0][i-1]+matrix[0][i];
        for(int j=1;j<n;j++) pre[j][0] = pre[j-1][0]+matrix[j][0];
        for(int i=1;i<n;i++){
            for(int j=1;j<m;j++){
                pre[i][j] = pre[i-1][j]+pre[i][j-1]-pre[i-1][j-1]+matrix[i][j];
            }
        }
    }
    
    int sumRegion(int row1, int col1, int row2, int col2) {
        int ans = pre[row2][col2];
        ans += (row1 && col1) ? pre[row1-1][col1-1]:0;
        ans -= (row1) ? pre[row1-1][col2]:0;
        ans -= (col1) ? pre[row2][col1-1]:0;
        return ans;
    }

	
Que 29: Coin change	---------> Important

You are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need 
to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.

Example 1:

Input: coins = [1, 2, 5], amount = 11
Output: 3 
Explanation: 11 = 5 + 5 + 1

 int coinChange(vector<int>& coins, int amount) 
    {
        int n=coins.size();
        vector<vector<int> >dp(n+1,vector<int>(amount+1));
        for(int j=1;j<=amount;j++) dp[0][j] = 1e9;
        for(int i=0;i<=n;i++) dp[i][0] = 0;
        for(int i=1;i<=n;i++){
            for(int j=1;j<=amount;j++){
                if(coins[i-1] <= j){
                    dp[i][j] = min(1+dp[i][j-coins[i-1]],dp[i-1][j]);
                }
                else
                    dp[i][j] = dp[i-1][j];
            }
        }
        return dp[n][amount] == 1e9 ? -1 : dp[n][amount];
  }


Que 30: Counting bits

Given a non negative integer number num. For every numbers i in the range 0 ≤ i ≤ num calculate the number of 1's in their binary representation and return them 
as an array.

Example 1:

Input: 2
Output: [0,1,1]

//Approach:Index : 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15

num : 0 1 1 2 1 2 2 3 1 2 2 3 2 3 3 4

Do you find the pattern?

Obviously, this is overlap sub problem, and we can come up the DP solution. For now, we need find the function to implement DP.

dp[0] = 0;

dp[1] = dp[0] + 1;

dp[2] = dp[0] + 1;

dp[3] = dp[1] +1;

dp[4] = dp[0] + 1;

dp[5] = dp[1] + 1;

dp[6] = dp[2] + 1;

dp[7] = dp[3] + 1;

dp[8] = dp[0] + 1;
...

This is the function we get, now we need find the other pattern for the function to get the general function. After we analyze the above function, we can get
dp[0] = 0;

dp[1] = dp[1-1] + 1;

dp[2] = dp[2-2] + 1;

dp[3] = dp[3-2] +1;

dp[4] = dp[4-4] + 1;

dp[5] = dp[5-4] + 1;

dp[6] = dp[6-4] + 1;

dp[7] = dp[7-4] + 1;

dp[8] = dp[8-8] + 1;
..

Obviously, we can find the pattern for above example, so now we get the general function

dp[index] = dp[index - offset] + 1;

vector<int> countBits(int num) {
        vector<int>dp(num+1,0);
        int offset = 1;
        for(int i=1;i<=num;i++){
            if(offset*2 == i)
                offset *= 2;
            dp[i] = dp[i-offset]+1;
        }
        return dp;
    }


Que 31: Integer break

Given a positive integer n, break it into the sum of at least two positive integers and maximize the product of those integers. Return the maximum product you can get.

Example 1:

Input: 2
Output: 1
Explanation: 2 = 1 + 1, 1 × 1 = 1.

//Approach:The first thing we should consider is : What is the max product if we break a number N into two factors?

I use a function to express this product: f=x(N-x)

When x=N/2, we get the maximum of this function.

However, factors should be integers. Thus the maximum is (N/2)*(N/2) when N is even or (N-1)/2 *(N+1)/2 when N is odd.

When the maximum of f is larger than N, we should do the break.

(N/2)*(N/2)>=N, then N>=4

(N-1)/2 *(N+1)/2>=N, then N>=5

These two expressions mean that factors should be less than 4, otherwise we can do the break and get a better product. The factors in last result should be 1, 2 or 3. Obviously, 1 should be abandoned. Thus, the factors of the perfect product should be 2 or 3.

The reason why we should use 3 as many as possible is

For 6, 3 * 3>2 * 2 * 2. Thus, the optimal product should contain no more than three 2.*/

 int integerBreak(int n) 
    {
        if(n==2)
            return 1;
        if(n==3)
            return 2;
        int product=1;
        while(n>4)
        {
            product*=3;
            n=n-3;
        }
        product*=n;
        return product;
    }

Que 32: Largest divisible subset

Given a set of distinct positive integers, find the largest subset such that every pair (Si, Sj) of elements in this subset satisfies:

Si % Sj = 0 or Sj % Si = 0.

If there are multiple solutions, return any subset is fine.

Example 1:

Input: [1,2,3]
Output: [1,2] (of course, [1,3] will also be ok)
Example 2:

Input: [1,2,4,8]
Output: [1,2,4,8]


//Approach:1. Sort all array elements in increasing order. The purpose of sorting is to make sure that all divisors of an element appear before it.
2. Create an array dp[] of same size as input array. dp[i] stores size of divisible subset ending with arr[i] (In sorted array). The minimum value of dp[i] would be 1.
3. Traverse all array elements. For every element, find a divisor arr[j] with largest value of dp[j] and store the value of dp[i] as dp[j] + 1.*/

vector<int> largestDivisibleSubset(vector<int>& nums) {
        int n=nums.size();
        vector<int>res;
        if(n==0) return res;
        int count[n],pre[n];
        int max=0,index=-1;
        sort(nums.begin(),nums.end());
        for(int i=0;i<n;i++){
            count[i]=1;
            pre[i]=-1;
            for(int j=i-1;j>=0;j--){
                if(nums[i]%nums[j]==0){
                  if(1+count[j]>count[i]){
                      count[i]=1+count[j];
                      pre[i]=j;
                  }
                }
            }
            if(count[i]>max){
                max=count[i];
                index=i;
            }
        }  
        while(index!=-1){
            res.push_back(nums[index]);
            index=pre[index];
        }
        return res;
    }

Que 33: Wiggle subsequence

A sequence of numbers is called a wiggle sequence if the differences between successive numbers strictly alternate between positive and negative. The first difference (if one exists) may be either positive or negative. A sequence with fewer than two elements is trivially a wiggle sequence.

For example, [1,7,4,9,2,5] is a wiggle sequence because the differences (6,-3,5,-7,3) are alternately positive and negative. In contrast, [1,4,7,2,5] and [1,7,4,5,5] are not wiggle sequences, the first because its first two differences are positive and the second because its last difference is zero.

Given a sequence of integers, return the length of the longest subsequence that is a wiggle sequence. A subsequence is obtained by deleting some number of elements (eventually, also zero) from the original sequence, leaving the remaining elements in their original order.

Example 1:

Input: [1,7,4,9,2,5]
Output: 6
Explanation: The entire sequence is a wiggle sequence.
Example 2:

Input: [1,17,5,10,13,15,10,5,16,8]
Output: 7
Explanation: There are several subsequences that achieve this length. One is [1,17,10,13,10,16,8].

int wiggleMaxLength(vector<int>& a) 
    {
        int n=a.size();
        if(n<2) return n;
        vector<int>up(n,1);
        vector<int>down(n,1);
        for(int i=1;i<n;i++)
        {
            for(int j=0;j<i;j++)
            {
                if(a[i]>a[j])
                    up[i]=max(down[j]+1,up[i]);
                if(a[j]>a[i])
                    down[i]=max(up[j]+1,down[i]);
            }
        }
        return max(up[n-1],down[n-1]);
    }


Que 34: combination sum

 public int combinationSum4(int[] nums, int target)
    {
        int[] dp=new int[target+1];
        dp[0]=1;
        for(int i=1;i<=target;i++)
        {
            for(int n:nums)
            {
                if(i>=n)
                dp[i]+=dp[i-n];
            }
        }
        return dp[target];
    }

Que 35: Is subsequence

Given a string s and a string t, check if s is subsequence of t.

//Recurrence used
dp[i][j] = { 	dp[i-1][j-1] 	if s[i] == t[j]
		dp[i][j-1] 	if s[i] != t[j]
	    }


Que 36: Distinct subsequence 2

Given a string S, count the number of distinct, non-empty subsequences of S .

Since the result may be large, return the answer modulo 10^9 + 7.

Example 1:

Input: "abc"
Output: 7
Explanation: The 7 distinct subsequences are "a", "b", "c", "ab", "ac", "bc", and "abc".

Let's try for a dynamic programming solution. In order to not repeat work, our goal is to phrase the current problem in terms of the answer to previous problems. A typical idea will be to try to count the number of states dp[k] (distinct subsequences) that use letters S[0], S[1], ..., S[k].

Naively, for say, S = "abcx", we have dp[k] = dp[k-1] * 2. This is because for dp[2] which counts ("", "a", "b", "c", "ab", "ac", "bc", "abc"), dp[3] counts all of those, plus all of those with the x ending, like ("x", "ax", "bx", "cx", "abx", "acx", "bcx", "abcx").

However, for something like S = "abab", let's play around with it. We have:

dp[0] = 2, as it counts ("", "a")
dp[1] = 4, as it counts ("", "a", "b", "ab");
dp[2] = 7 as it counts ("", "a", "b", "aa", "ab", "ba", "aba");
dp[3] = 12, as it counts ("", "a", "b", "aa", "ab", "ba", "bb", "aab", "aba", "abb", "bab", "abab").
We have that dp[3]countsdp[2], plus("b", "aa", "ab", "ba", "aba")with"b"added to it. Notice that("", "a")are missing from this list, as they get double counted. In general, the sequences that resulted from putting"b"the last time (ie."b", "ab"`) will get double counted.

This insight leads to the recurrence:

dp[k] = 2 * dp[k-1] - dp[last[S[k]] - 1]

The number of distinct subsequences ending at S[k], is twice the distinct subsequences counted by dp[k-1] (all of them, plus all of them with S[k] appended), minus the amount we double counted, which is dp[last[S[k]] - 1].

   int MOD = 1e9+7;
public:
    int distinctSubseqII(string S) {
        int n = S.size();
        vector<int>dp(n+1,0);
        vector<int>last(26,-1);
        dp[0] = 1;
        for(int i=1;i<=n;i++){
            int x = S[i-1]-'a';
            dp[i] = (2*dp[i-1])%MOD;	
            if(last[x] >=0 )
                dp[i] -= dp[last[x]-1];
            dp[i] %= MOD;
            last[x] = i;
        }
        dp[n]--;	// to avoid empty subsequence
        if(dp[n] < 0) dp[n] += MOD;
        return dp[n];
    }


